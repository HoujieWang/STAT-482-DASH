logOdds_dem2012 = log(sang_election$pct_dem_12/(1-sang_election$pct_dem_12))
y = logOdds_dem2016 - logOdds_dem2012
y = scale(y)
Data = cbind(y, full_data[, -c(1: 4)])
locs = sang_election[, 1: 5]
############################### Sptial Structure ###############################
# load("data.Rdata"); load("locs.Rdata")
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
# nb.mat = nb.mat[as.vector(sapply(as.character(locs$Id2), function(x){which(x == rownames(nb.mat))})), ]
# nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(nb.mat)
# fit = lm(Data$y~., data = Data)
# is.na(coef(fit))
# Data = Data[, !is.na(coef(fit))]
set.seed(101)
fit.lasso = cv.glmnet(x = as.matrix(Data[, -1]), y = y, family = "gaussian")
coef_lasso = coef(fit.lasso, s = "lambda.min")
Data = Data[, c(1, (which(coef_lasso[-1] != 0)+1))]
fit = lm(Data$y~., data = Data)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
shapiro.test(residuals(fit))
durbinWatsonTest(fit)
ncvTest(fit)
sqrt(vif(fit)) > 2
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
# Crude Analysis
fit = lm(Data$y~., data = Data)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
shapiro.test(residuals(fit))
durbinWatsonTest(fit)
ncvTest(fit)
sqrt(vif(fit)) > 2
save(Data, file = "Data.RData); save(locs, file = "locs.Rdata)
save(Data, file = "Data.RData"); save(locs, file = "locs.Rdata")
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
fit2 = lagsarlm(data$y~., data = data, nb.w)
summary(fit2)
nb.mat
locs$fips
colnames(nb.mat)
nb.mat
nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
rownames(nb.mat)
colnames(nb.mat)
as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))}))
as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))
nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
all.equal(colnames(nb.mat),rownames(nb.mat))
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
# nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(nb.mat)
fit = lm(Data$y~., data = Data)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
shapiro.test(residuals(fit))
durbinWatsonTest(fit)
ncvTest(fit)
sqrt(vif(fit)) > 2
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
fit2 = lagsarlm(data$y~., data = data, nb.w)
summary(fit2)
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(nb.mat)
############################### Regression Analysis ##############################
# Crude Analysis
fit = lm(Data$y~., data = Data)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
shapiro.test(residuals(fit))
durbinWatsonTest(fit)
ncvTest(fit)
sqrt(vif(fit)) > 2
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
fit2 = lagsarlm(data$y~., data = data, nb.w)
summary(fit2)
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
# nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
# nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(nb.mat)
############################### Regression Analysis ##############################
# Crude Analysis
fit = lm(Data$y~., data = Data)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
shapiro.test(residuals(fit))
durbinWatsonTest(fit)
ncvTest(fit)
sqrt(vif(fit)) > 2
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(nb.mat)
fit = lm(Data$y~., data = Data)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
shapiro.test(residuals(fit))
durbinWatsonTest(fit)
ncvTest(fit)
sqrt(vif(fit)) > 2
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
hist(residuals(fit2))
shapiro.test(residuals(fit2))
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
hist(residuals(fit2))
shapiro.test(residuals(fit2))
dev.off()
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
# nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
# nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
# nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(nb.mat)
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
hist(residuals(fit2))
shapiro.test(residuals(fit2))
library(igraph); library(spdep); library(spatialreg); library(MASS); library(car); library(DHARMa); library(tseries); library(sp)
?spDistsN1
spDistsN1(as.matrix(locs[, 1:2]))
?spDistsN1
spDistsN1(as.matrix(locs[, 1:2], locs[1, 1:2]))
spDistsN1(pts = as.matrix(locs[, 1:2], pt = locs[1, 1:2]))
spDists(pts = as.matrix(locs[, 1:2])
)
spDists(as.matrix(locs[, 1:2])
)
# nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
# nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
# nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
dist_mat = spDists(as.matrix(locs[, 1:2]))
View(dist_mat)
as.matrix(locs[, 1:2])
locs[, 1: 5]
spDists(as.matrix(locs[, 1:2]))
2.74575*1.6
dist_mat
locs
3.81266*1.6
ï¼ŸspDists
?spDists
dim(dist_mat)
dist_mat[1, 800]
nb.mat = nb.mat*dist_mat
View(nb.mat)
nb.mat[1, ]
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
dist_mat = spDists(as.matrix(locs[, 1:2]))
nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
nb.mat = nb.mat*dist_mat
View(nb.mat)
nb.mat[1, ]
nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(nb.mat)
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
hist(residuals(fit2))
shapiro.test(residuals(fit2))
ncvTest(fit2)
sqrt(vif(fit2)) > 2
fit3 = errorsarlm(Data$y~., data = Data, nb.w)
summary(fit3)
shapiro.test(residuals(fit3))
fit4 = errorsarlm(Data$y~., data = Data, nb.w, type = "mixed")
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
dist_mat = spDists(as.matrix(locs[, 1:2]))
# nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
# nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
# nb.mat = nb.mat*dist_mat
# nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(dist_mat)
fit = lm(Data$y~., data = Data)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
shapiro.test(residuals(fit))
durbinWatsonTest(fit)
ncvTest(fit)
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
hist(residuals(fit2))
shapiro.test(residuals(fit2))
fit3 = errorsarlm(Data$y~., data = Data, nb.w)
summary(fit3)
shapiro.test(residuals(fit3))
fit4 = errorsarlm(Data$y~., data = Data, nb.w, type = "mixed")
summary(fit4)
shapiro.test(residuals(fit4))
# nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
# nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
# nb.mat = nb.mat*dist_mat
nb.mat = dist_mat
# nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(dist_mat)
nb.w$weights
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
dist_mat = spDists(as.matrix(locs[, 1:2]))
nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
nb.mat = nb.mat*dist_mat
# nb.mat = dist_mat
nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(dist_mat)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
rm(list = ls())
library(igraph); library(spdep); library(spatialreg); library(MASS); library(car); library(DHARMa); library(tseries); library(sp)
# sang_election = read.csv(file = "election_couty_cleaned.csv")
# load(file = "full_data.Rdata")
############################### Data Filtering ###############################
full_data = full_data[-632,]
sang_election= sang_election[-623,]
ind = intersect(sang_election$fips, full_data$Id2)
y_ind = sapply(ind, function(x){which(x == sang_election$fips)})
X_ind = sapply(ind, function(x){which(x == full_data$Id2)})
y_ind = y_ind[order(as.integer(names(y_ind)))]
sang_election = sang_election[y_ind, ]
X_ind = sort(X_ind)
full_data = full_data[X_ind, ]
logOdds_dem2016 = log(sang_election$pct_dem_16/(1-sang_election$pct_dem_16))
logOdds_dem2012 = log(sang_election$pct_dem_12/(1-sang_election$pct_dem_12))
y = logOdds_dem2016 - logOdds_dem2012
y = scale(y)
Data = cbind(y, full_data[, -c(1: 4)])
locs = sang_election[, 1: 5]
set.seed(101)
fit.lasso = cv.glmnet(x = as.matrix(Data[, -1]), y = y, family = "gaussian")
coef_lasso = coef(fit.lasso, s = "lambda.min")
Data = Data[, c(1, (which(coef_lasso[-1] != 0)+1))]
# save(Data, file = "Data.RData"); save(locs, file = "locs.Rdata")
############################### Sptial Structure ###############################
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
dist_mat = spDists(as.matrix(locs[, 1:2]))
nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
nb.mat = nb.mat*dist_mat
# nb.mat = dist_mat
nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(dist_mat)
############################### Regression Analysis ##############################
# Crude Analysis
fit = lm(Data$y~., data = Data)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
shapiro.test(residuals(fit))
durbinWatsonTest(fit)
ncvTest(fit)
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
hist(residuals(fit2))
shapiro.test(residuals(fit2))
fit3 = errorsarlm(Data$y~., data = Data, nb.w)
summary(fit3)
shapiro.test(residuals(fit3))
# for (i in 1: 10){
#   ind = sample(1: nrow(data), 170, replace = F)
#   data_tst = data[ind, ]; data_trn = data[-ind, ]
#   subFIPSid = V(G)$name %in% locs$Id2
#   countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
#   graph0 = permute(countyGraph, order(V(countyGraph)$name));
#   nb.mat = as_adjacency_matrix(graph0)
#   nb.mat = nb.mat[as.vector(sapply(as.character(locs$Id2), function(x){which(x == rownames(nb.mat))})), ]
#   nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
#   nb.w_trn = mat2listw(nb.mat)
#   fit = lagsarlm(data_trn$y~., data = data_trn, nb.w_trn)
#   subFIPSid = V(G)$name %in% locs$Id2[ind]
#   countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
#   graph0 = permute(countyGraph, order(V(countyGraph)$name));
#   nb.mat = as_adjacency_matrix(graph0)
#   nb.mat = nb.mat[as.vector(sapply(as.character(locs$Id2[ind]), function(x){which(x == rownames(nb.mat))})), ]
#   nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
#   nb.w_tst = mat2listw(nb.mat)
#   predict(fit, data_tst[, -1], nb.w_tst)
#
# }
sang_election = read.csv(file = "election_couty_cleaned.csv")
load(file = "full_data.Rdata")
############################### Data Filtering ###############################
full_data = full_data[-632,]
sang_election= sang_election[-623,]
ind = intersect(sang_election$fips, full_data$Id2)
y_ind = sapply(ind, function(x){which(x == sang_election$fips)})
X_ind = sapply(ind, function(x){which(x == full_data$Id2)})
y_ind = y_ind[order(as.integer(names(y_ind)))]
sang_election = sang_election[y_ind, ]
X_ind = sort(X_ind)
full_data = full_data[X_ind, ]
logOdds_dem2016 = log(sang_election$pct_dem_16/(1-sang_election$pct_dem_16))
logOdds_dem2012 = log(sang_election$pct_dem_12/(1-sang_election$pct_dem_12))
y = logOdds_dem2016 - logOdds_dem2012
y = scale(y)
Data = cbind(y, full_data[, -c(1: 4)])
locs = sang_election[, 1: 5]
set.seed(101)
fit.lasso = cv.glmnet(x = as.matrix(Data[, -1]), y = y, family = "gaussian")
coef_lasso = coef(fit.lasso, s = "lambda.min")
Data = Data[, c(1, (which(coef_lasso[-1] != 0)+1))]
# save(Data, file = "Data.RData"); save(locs, file = "locs.Rdata")
############################### Sptial Structure ###############################
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
dist_mat = spDists(as.matrix(locs[, 1:2]))
nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
nb.mat = nb.mat*dist_mat
# nb.mat = dist_mat
nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(dist_mat)
############################### Regression Analysis ##############################
# Crude Analysis
fit = lm(Data$y~., data = Data)
summary(fit)
par(mfrow = c(2,2))
plot(fit)
shapiro.test(residuals(fit))
durbinWatsonTest(fit)
ncvTest(fit)
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
hist(residuals(fit2))
shapiro.test(residuals(fit2))
fit3 = errorsarlm(Data$y~., data = Data, nb.w)
summary(fit3)
shapiro.test(residuals(fit3))
# for (i in 1: 10){
#   ind = sample(1: nrow(data), 170, replace = F)
#   data_tst = data[ind, ]; data_trn = data[-ind, ]
#   subFIPSid = V(G)$name %in% locs$Id2
#   countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
#   graph0 = permute(countyGraph, order(V(countyGraph)$name));
#   nb.mat = as_adjacency_matrix(graph0)
#   nb.mat = nb.mat[as.vector(sapply(as.character(locs$Id2), function(x){which(x == rownames(nb.mat))})), ]
#   nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
#   nb.w_trn = mat2listw(nb.mat)
#   fit = lagsarlm(data_trn$y~., data = data_trn, nb.w_trn)
#   subFIPSid = V(G)$name %in% locs$Id2[ind]
#   countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
#   graph0 = permute(countyGraph, order(V(countyGraph)$name));
#   nb.mat = as_adjacency_matrix(graph0)
#   nb.mat = nb.mat[as.vector(sapply(as.character(locs$Id2[ind]), function(x){which(x == rownames(nb.mat))})), ]
#   nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
#   nb.w_tst = mat2listw(nb.mat)
#   predict(fit, data_tst[, -1], nb.w_tst)
#
# }
nb.mat
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
dist_mat = spDists(as.matrix(locs[, 1:2]))
# nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
# nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
# nb.mat = nb.mat*dist_mat
nb.mat = dist_mat
nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(dist_mat)
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
hist(residuals(fit2))
shapiro.test(residuals(fit2))
rawData = read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G = graph.edgelist(as.matrix(rawData), directed=FALSE)
G = simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid = V(G)$name %in% locs$fips
countyGraph = induced.subgraph(G, V(G)[subFIPSid]);
graph0 = permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat = as_adjacency_matrix(graph0)
# dist_mat = spDists(as.matrix(locs[, 1:2]))
# nb.mat = nb.mat[as.vector(sapply(as.character(locs$fips), function(x){which(x == rownames(nb.mat))})), ]
# nb.mat = nb.mat[, as.vector(sapply(as.character(locs$fips), function(x){which(x == colnames(nb.mat))}))]
# nb.mat = nb.mat*dist_mat
# nb.mat = dist_mat
nb.mat = apply(nb.mat, 2, function(x){x/sum(x)})
nb.w = mat2listw(dist_mat)
fit2 = lagsarlm(Data$y~., data = Data, nb.w)
summary(fit2)
hist(residuals(fit2))
shapiro.test(residuals(fit2))
View(nb.mat)
