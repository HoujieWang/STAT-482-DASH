sim_df[, 3]
ggplot() + geom_point(aes(x = 1:100, y = sim_df[, 1]), position=position_jitter(.005), col = 'red') +
geom_errorbar(aes(x = 1:100, ymin=sim_df[, 2] - sim_df[, 3] , ymax= sim_df[, 3] + sim_df[, 2]), , width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
sim_df[, 2]
ggplot() + geom_point(aes(x = 1:100, y = sim_df[, 1]), position=position_jitter(.005), col = 'red') +
geom_errorbar(aes(x = 1:100, ymin= sim_df[, 1] - sim_df[, 3] , ymax= sim_df[, 1] + sim_df[, 2]), , width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
sim_df[, 2]
sim_df[, 1] + sim_df[, 2]
ggplot() + geom_point(aes(x = 1:100, y = sim_df[, 1]), position=position_jitter(.005), col = 'red') +
geom_errorbar(aes(x = 1:100, ymin= sim_df[, 3] , ymax= sim_df[, 2]), , width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
ggplot() + geom_point(aes(x = 1:100, y = sim_df[, 1]), col = 'red') +
geom_errorbar(aes(x = 1:100, ymin= sim_df[, 3] , ymax= sim_df[, 2]),width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
library(tidyverse)
library(cowplot)
theme_set(theme_cowplot())
sim_dat <- map(1:100, ~rbinom(n = 1000, size = 1,  prob = 0.7))
sim_dat_mn <- map_dbl(sim_dat, ~mean(.x))
sim_dat_sd <- map_dbl(sim_dat_mn, ~ sqrt(.x*(1-.x)/1000))
sim_dat_cofintup <- sim_dat_mn + 1.96 * sim_dat_sd
sim_dat_cofintlw <- sim_dat_mn - 1.96 * sim_dat_sd
sum(sim_dat_cofintup > .70 & sim_dat_cofintlw < .70)
sim_df <- data.frame(sim_dat_mn, sim_dat_cofintup, sim_dat_cofintlw) %>%
.[order(sim_df$sim_dat_mn),]
ggplot() + geom_point(aes(x = 1:1000, y = sim_df[, 1]), col = 'red') +
geom_errorbar(aes(x = 1:100, ymin= sim_df[, 3] , ymax= sim_df[, 2]),width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
ggplot() + geom_point(aes(x = 1:1000, y = sim_df[, 1]), col = 'red') +
geom_errorbar(aes(x = 1:1000, ymin= sim_df[, 3] , ymax= sim_df[, 2]),width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
ggplot() + geom_point(aes(x = 1:1000, y = sim_df[, 1]), col = 'red') +
geom_errorbar(aes(x = 1:1000, ymin= sim_df[, 3] , ymax= sim_df[, 2]),width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
sim_dat <- map(1:100, ~rbinom(n = 1000, size = 1,  prob = 0.7))
sim_dat_mn <- map_dbl(sim_dat, ~mean(.x))
sim_dat_sd <- map_dbl(sim_dat_mn, ~ sqrt(.x*(1-.x)/1000))
sim_dat_cofintup <- sim_dat_mn + 1.96 * sim_dat_sd
sim_dat_cofintlw <- sim_dat_mn - 1.96 * sim_dat_sd
sum(sim_dat_cofintup > .70 & sim_dat_cofintlw < .70)
sim_df <- data.frame(sim_dat_mn, sim_dat_cofintup, sim_dat_cofintlw) %>%
.[order(sim_df$sim_dat_mn),]
sim_df <- data.frame(sim_dat_mn, sim_dat_cofintup, sim_dat_cofintlw) %>%
.[order(sim_df$sim_dat_mn),]
ggplot() + geom_point(aes(x = 1:1000, y = sim_df[, 1]), col = 'red') +
geom_errorbar(aes(x = 1:1000, ymin= sim_df[, 3] , ymax= sim_df[, 2]),width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
sim_df[, 1]
sim_dat <- map(1:100, ~rbinom(n = 1000, size = 1,  prob = 0.7))
sim_dat <- map(1:1000, ~rbinom(n = 1000, size = 1,  prob = 0.7))
sim_dat_mn <- map_dbl(sim_dat, ~mean(.x))
sim_dat_sd <- map_dbl(sim_dat_mn, ~ sqrt(.x*(1-.x)/1000))
sim_dat_cofintup <- sim_dat_mn + 1.96 * sim_dat_sd
sim_dat_cofintlw <- sim_dat_mn - 1.96 * sim_dat_sd
sum(sim_dat_cofintup > .70 & sim_dat_cofintlw < .70)
sim_df <- data.frame(sim_dat_mn, sim_dat_cofintup, sim_dat_cofintlw) %>%
.[order(sim_df$sim_dat_mn),]
ggplot() + geom_point(aes(x = 1:1000, y = sim_df[, 1]), col = 'red') +
geom_errorbar(aes(x = 1:1000, ymin= sim_df[, 3] , ymax= sim_df[, 2]),width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
sim_dat_mn
library(tidyverse)
library(cowplot)
theme_set(theme_cowplot())
sim_dat <- map(1:1000, ~rbinom(n = 1000, size = 1,  prob = 0.7))
sim_dat_mn <- map_dbl(sim_dat, ~mean(.x))
sim_dat_sd <- map_dbl(sim_dat_mn, ~ sqrt(.x*(1-.x)/1000))
sim_dat_cofintup <- sim_dat_mn + 1.96 * sim_dat_sd
sim_dat_cofintlw <- sim_dat_mn - 1.96 * sim_dat_sd
sum(sim_dat_cofintup > .70 & sim_dat_cofintlw < .70)
sim_df <- data.frame(sim_dat_mn, sim_dat_cofintup, sim_dat_cofintlw) %>%
.[order(sim_df$sim_dat_mn),]
ggplot() + geom_point(aes(x = 1:1000, y = sim_df[, 1]), col = 'red') +
geom_errorbar(aes(x = 1:1000, ymin= sim_df[, 3] , ymax= sim_df[, 2]),width=.5) +
geom_hline(aes(yintercept = .7)) +
theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank())
sim_dat_mn <- map_dbl(sim_dat, ~mean(.x))
sim_dat_sd <- map_dbl(sim_dat_mn, ~ sqrt(.x*(1-.x)/1000))
sim_dat_cofintup <- sim_dat_mn + 1.96 * sim_dat_sd
sim_dat_cofintlw <- sim_dat_mn - 1.96 * sim_dat_sd
sum(sim_dat_cofintup > .70 & sim_dat_cofintlw < .70)
sim_df <- data.frame(sim_dat_mn, sim_dat_cofintup, sim_dat_cofintlw) %>%
.[order(sim_df$sim_dat_mn),]
data.frame(sim_dat_mn, sim_dat_cofintup, sim_dat_cofintlw) %>%
.[order(sim_df$sim_dat_mn),]
order(sim_df$sim_dat_mn)
sim_dat_mn <- map_dbl(sim_dat, ~mean(.x))
sim_dat_sd <- map_dbl(sim_dat_mn, ~ sqrt(.x*(1-.x)/1000))
install.packages("rethinking")
library(rethinking)
install.packages(c("coda","mvtnorm","devtools","loo","dagitty"))
library(devtools)
devtools::install_github("rmcelreath/rethinking")
devtools::install_github("rmcelreath/rethinking")
devtools::install_github("rmcelreath/rethinking")
devtools::install_github("rmcelreath/rethinking")
install.packages(c("coda","mvtnorm","devtools","loo","dagitty"))
library(devtools)
install.packages(c("coda", "mvtnorm", "devtools", "loo", "dagitty"))
devtools::install_github("rmcelreath/rethinking")
devtools::install_github("rmcelreath/rethinking")
runif(1000)
mean(runif())
mean(runif(1e5))
mean(runif(1e9))
mean(runif(1e8))
x <- 1:1e6
y <- cumsum(x)/1:1e6
x <- 1:1e5
y <- cumsum(x)/1:1e5
y <- cumsum(as.numeric(x))/1:1e5
plot(x,y )
plot(x,y, type = 'l' )
plot(x,y, type = 'l' )
x <- runif(1e5)
y <- cumsum(as.numeric(x))/1:1e5
plot(x,y, type = 'l' )
plot(y,x, type = 'l' )
plot(1:1e5, y, type = 'l' )
plot(1:1e5, y, type = 'l', ylim = c(0,1))
R.version
#
# Animation (augmented version) of the conspiracy between nonlinearity and random X (A. Buja):
#
nonlinearity.randomX.animated.2 <- function(slowness=200, new=F) {
if(as.character(getRversion()) >= "2.14") on.exit(dev.flush(dev.hold(0)))
mu <- list(function(x) { x^2+1 }, function(x) { 1.5+x })
labs <- c("nonlinear  ","linear  ")
x.grid <- seq(0, 1, len=101)
x.pr <- c(-0.4, -0.1)  # x.pr[1] location of vertical axis, x.pr[2] end of slope vectors
y.slop <- c(1.7, 2.0)  # vertical coordinates for labels "linear" and "nonlinear" to "Slopes"
y.icpt <- sapply(mu, function(f) predict(lm(f(x.grid) ~ x.grid), newdata=data.frame(x.grid=x.pr[1])))
x.lim <- c(-0.6, +1.0)
y.lim <- c(0, 2.5)
N <- 10
x.new <- sort(runif(N))
y.0 <- list(c(),c())
y.1 <- list(c(),c())
if(new) dev.new(buffered=F, width=6, height=6)
par(mgp=c(1,.5,0), mar=c(3,3,3,6))
for(i in 1:500) { # Number of datasets generated
x.old <- x.new
x.new <- sort(runif(N))   # This is a dataset.
for(a in seq(0,1,length=slowness)) { # Interpolation in 'slowness' steps, default = 200
if(as.character(getRversion()) >= "2.14") dev.hold()
x <- (1-a)*x.old + a*x.new
plot(x=x.lim, y=y.lim, type="n", xlab="x", ylab=bquote(y == bold(mu) ( x )), xaxt="n", yaxt="n",
main="The Conspiracy of Nonlinearity and Random X")
axis(side=2) #!!!!!!!!!!!!!
abline(h=0, col="gray")                                            # hor axis
lines(c(0,1), c(0,0), lwd=3, col="gray")                           # hor x range [0,1]
abline(v=x.pr[1], col="gray")                                      # ver axis
mtext(text=paste("Dataset #",i,sep=""), side=1, line=1, at=par()$usr[1], adj=0.5)
mtext(text=paste("Y =",labs,"\ndeterministic\nresponse"), side=4, line=.5, adj=0,
at=sapply(mu, function(f) f(par()$usr[2])) - 0.1, las=1)
mtext(text="Random X\ndatasets", side=4, line=.5, at=y.lim[1], adj=0, las=1)
text(x=x.pr[1], y=mean(y.slop), lab="Slopes  ", adj=1, col="gray20", cex=0.8)
text(x=x.pr[1], y=mean(y.icpt), lab="Intercepts  ", adj=1, col="gray20", cex=0.8)
for(j in 1:length(mu)) {     # Looping over functions mu[[j]]
y.grid <- mu[[j]](x.grid)
y <- mu[[j]](x)
m <- lm(y ~ x)
f <- fitted(m)
lines(x=x.grid, y=y.grid, col="gray70", lwd=6)                     # gray curve
abline(m, lwd=2)                                                   # fitted line
lines( x=c(rbind(x,x,NA)), y=c(rbind(pmax(f,y),0,NA)), col="gray") # ver lines to points
points(x=x, y=y, pch=16, cex=1.2, col="blue")                      # blue points on curve
points(x=x, y=rep(0,length(x)), pch=16, cex=1.2)                   # black points on x axis
points(x=x, y=f, cex=1.2, col="red")                               # red points on fit
text(x=x.pr[1], y=y.slop[j], lab=labs[j], adj=1, col="gray20", cex=0.8)
text(x=x.pr[1], y=y.icpt[j], lab=labs[j], adj=1, col="gray20", cex=0.8)
if(length(y.0[[j]])>0) {
points(x=rep(x.pr[1], length(y.0[[j]])), y=y.0[[j]], pch=3, col="red")
lines(x=rep(c(x.pr[1],x.pr[2],NA), length(y.0[[j]])),
y=y.slop[j]+c(rbind(0,y.1[[j]]-y.0[[j]],NA)), col="red")
}
if(a==1) {   # a = interpolation parameter; a==1 means arrived at end of an interpolation
y.pr <- predict(m, newdata=data.frame(x=x.pr))
y.0[[j]][i] <- y.pr[1]
y.1[[j]][i] <- y.pr[2]
lines(x=x.pr[c(1,2,2)], y=y.pr[c(1,1,2)], col="red", lwd=2)   # triangle lines
points(x=x.pr, y=y.pr, col="red", cex=1.5, pch=16)            # 2 triangle points
lines(x=x.pr,  y=y.slop[j]+c(0,diff(y.pr)), col="black", lwd=2)         # triangle line from base
points(x=x.pr, y=y.slop[j]+c(0,diff(y.pr)), col="red", cex=1.5, pch=16) # 2 triangle points from base
}
} # looping over j for mu[[j]]
if(i==1 & a==0) {
txt <- "  Animation about to begin:  "
for(k in 5:1) {
txt <- paste(txt, k)
text(x=x.pr[1], y=par()$usr[4], adj=c(0,2), lab=txt)
dev.flush()
Sys.sleep(1)
}
}
if(as.character(getRversion()) >= "2.14") dev.flush()
} # looping over a
Sys.sleep(1.5)
} # looping over i for datasets x.new
}
nonlinearity.randomX.animated.2()
#
# Animation (augmented version) of the conspiracy between nonlinearity and random X (A. Buja):
#
nonlinearity.randomX.animated.2 <- function(slowness=200, new=F) {
if(as.character(getRversion()) >= "2.14") on.exit(dev.flush(dev.hold(0)))
mu <- list(function(x) { x^2+1 }, function(x) { 1.5+x })
labs <- c("nonlinear  ","linear  ")
x.grid <- seq(0, 1, len=101)
x.pr <- c(-0.4, -0.1)  # x.pr[1] location of vertical axis, x.pr[2] end of slope vectors
y.slop <- c(1.7, 2.0)  # vertical coordinates for labels "linear" and "nonlinear" to "Slopes"
y.icpt <- sapply(mu, function(f) predict(lm(f(x.grid) ~ x.grid), newdata=data.frame(x.grid=x.pr[1])))
x.lim <- c(-0.6, +1.0)
y.lim <- c(0, 2.5)
N <- 10
x.new <- sort(runif(N))
y.0 <- list(c(),c())
y.1 <- list(c(),c())
if(new) dev.new(buffered=F, width=6, height=6)
par(mgp=c(1,.5,0), mar=c(3,3,3,6))
for(i in 1:500) { # Number of datasets generated
x.old <- x.new
x.new <- sort(runif(N))   # This is a dataset.
for(a in seq(0,1,length=slowness)) { # Interpolation in 'slowness' steps, default = 200
if(as.character(getRversion()) >= "2.14") dev.hold()
x <- (1-a)*x.old + a*x.new
plot(x=x.lim, y=y.lim, type="n", xlab="x", ylab=bquote(y == bold(mu) ( x )), xaxt="n", yaxt="n",
main="The Conspiracy of Nonlinearity and Random X")
axis(side=2) #!!!!!!!!!!!!!
abline(h=0, col="gray")                                            # hor axis
lines(c(0,1), c(0,0), lwd=3, col="gray")                           # hor x range [0,1]
abline(v=x.pr[1], col="gray")                                      # ver axis
mtext(text=paste("Dataset #",i,sep=""), side=1, line=1, at=par()$usr[1], adj=0.5)
mtext(text=paste("Y =",labs,"\ndeterministic\nresponse"), side=4, line=.5, adj=0,
at=sapply(mu, function(f) f(par()$usr[2])) - 0.1, las=1)
mtext(text="Random X\ndatasets", side=4, line=.5, at=y.lim[1], adj=0, las=1)
text(x=x.pr[1], y=mean(y.slop), lab="Slopes  ", adj=1, col="gray20", cex=0.8)
text(x=x.pr[1], y=mean(y.icpt), lab="Intercepts  ", adj=1, col="gray20", cex=0.8)
for(j in 1:length(mu)) {     # Looping over functions mu[[j]]
y.grid <- mu[[j]](x.grid)
y <- mu[[j]](x)
m <- lm(y ~ x)
f <- fitted(m)
lines(x=x.grid, y=y.grid, col="gray70", lwd=6)                     # gray curve
abline(m, lwd=2)                                                   # fitted line
lines( x=c(rbind(x,x,NA)), y=c(rbind(pmax(f,y),0,NA)), col="gray") # ver lines to points
points(x=x, y=y, pch=16, cex=1.2, col="blue")                      # blue points on curve
points(x=x, y=rep(0,length(x)), pch=16, cex=1.2)                   # black points on x axis
points(x=x, y=f, cex=1.2, col="red")                               # red points on fit
text(x=x.pr[1], y=y.slop[j], lab=labs[j], adj=1, col="gray20", cex=0.8)
text(x=x.pr[1], y=y.icpt[j], lab=labs[j], adj=1, col="gray20", cex=0.8)
if(length(y.0[[j]])>0) {
points(x=rep(x.pr[1], length(y.0[[j]])), y=y.0[[j]], pch=3, col="red")
lines(x=rep(c(x.pr[1],x.pr[2],NA), length(y.0[[j]])),
y=y.slop[j]+c(rbind(0,y.1[[j]]-y.0[[j]],NA)), col="red")
}
if(a==1) {   # a = interpolation parameter; a==1 means arrived at end of an interpolation
y.pr <- predict(m, newdata=data.frame(x=x.pr))
y.0[[j]][i] <- y.pr[1]
y.1[[j]][i] <- y.pr[2]
lines(x=x.pr[c(1,2,2)], y=y.pr[c(1,1,2)], col="red", lwd=2)   # triangle lines
points(x=x.pr, y=y.pr, col="red", cex=1.5, pch=16)            # 2 triangle points
lines(x=x.pr,  y=y.slop[j]+c(0,diff(y.pr)), col="black", lwd=2)         # triangle line from base
points(x=x.pr, y=y.slop[j]+c(0,diff(y.pr)), col="red", cex=1.5, pch=16) # 2 triangle points from base
}
} # looping over j for mu[[j]]
if(i==1 & a==0) {
txt <- "  Animation about to begin:  "
for(k in 5:1) {
txt <- paste(txt, k)
text(x=x.pr[1], y=par()$usr[4], adj=c(0,2), lab=txt)
dev.flush()
Sys.sleep(1)
}
}
if(as.character(getRversion()) >= "2.14") dev.flush()
} # looping over a
Sys.sleep(1.5)
} # looping over i for datasets x.new
}
nonlinearity.randomX.animated.2()
install.packages("rnoaa")
library(rnoaa)
rnoaa::homr(qid = 'COOP:046742')
out <- rnoaa::homr(qid = 'COOP:046742')
out
rnoaa::ghcnd_states("Texas") GHCND
rnoaa::ghcnd_states("Texas")
ncdc_locs()
library(rnoaa)
my_token <- "TRUPCWweQbPjiXsfKCHqEokUUMZkitIs"
options(noaakey = my_token)
ncdc_locs()
ncdc(datasetid = "GHCND	", limit = 4)
ncdc(datasetid = "GHCND	", startdate= '2010-05-10', limit = 4)
ncdc(datasetid = "GHCND	", startdate='2010-05-10', enddate='2010-06-10', limit = 4)
fipscodes
filter(fipscodes, state == "Texas")
filter(fipscodes, State == "Texas")
fipscodes
filter(fipscodes, state == Texas)
library(tidyverse)
library(tidyverse)
filter(fipscodes, state == Texas)
filter(fipscodes, state == "Texas")
filter(fipscodes, state == "Texas")$fips
texas_fips <- filter(fipscodes, state == "Texas")$fips
library(rnoaa)
my_token <- "TRUPCWweQbPjiXsfKCHqEokUUMZkitIs"
options(noaakey = my_token)
ncdc(datasetid = "NORMAL_HLY",  , startdate='2010-05-10', enddate='2010-06-10', limit = 4, )
isd_stations()
stat <- isd_stations()
stat
require(maggitr)
require(magrittr)
stations <- ghcnd_stations()
my_token <- "TRUPCWweQbPjiXsfKCHqEokUUMZkitIs" # Token generated using my email (dwfletcher215@tamu.edu)
options(noaakey = my_token)
stations <- ghcnd_states()
stations
stations <- ghcnd_stations()
require(rnoaa)
require(magrittr)
my_token <- "TRUPCWweQbPjiXsfKCHqEokUUMZkitIs" # Token generated using my email (dwfletcher215@tamu.edu)
options(noaakey = my_token)                    # Sets token allowing interaction with API
stations <- ghcnd_stations()
tx_stations <- stations %>% filter(state == "TX")
tx_stations
ncdc(datasetid = "LCD",  , startdate='2010-05-10', enddate='2010-06-10', limit = 4)
lcd(datasetid = "LCD",  , startdate='2010-05-10', enddate='2010-06-10', limit = 4)
lcd(tx_stations[1], year = 2013)
tx_stations
tx_stations[100,] <- stations %>% filter(state == "TX")
tx_stations[100,]
stations <- ghcnd_stations()
cite(rnoaa)
cite("rnoaa")
cite(rnoaa)
X <- runif(1000, -4, 4)
Y <- exp(7*X)/(1+exp(7*))
Y <- exp(7*X)/(1+exp(7*X))
X <- runif(1000, -4, 4)
Y <- exp(7*X)/(1+exp(7*X)) + rnorm(1000, sd = 0.01)
plot(X,Y, type = 'l')
plot(X,Y, type = 'b')
plot(X,Y)
install.packages("rneg")
library(rneg)
install.packages('KernSmooth')
library(KernSmooth)
KernSmooth::locpoly(X, Y)
KernSmooth::locpoly(X, Y, bandwidth = 1)
plot(KernSmooth::locpoly(X, Y, bandwidth = 1))
plot(KernSmooth::locpoly(X, Y, bandwidth = 1), type = 'l')
require(rnoaa); require(magrittr)
my_token <- "TRUPCWweQbPjiXsfKCHqEokUUMZkitIs" # Token generated using my email (dwfletcher215@tamu.edu)
options(noaakey = my_token) # Sets token allowing interaction with API
Sys.Date()
Sys.Date();Sys.time()
Sys.Date() - 1
current_date <- Sys.Date()
stations <- isd_stations()
stations
names(stations)
stations[100,]
stations[1000,]
stations[10000,]
stations[100000,]
stations[2000,]
tx_stations <- isd_stations() %>% filter(state == "tx")
tx_stations
tx_stations <- isd_stations() %>% filter(state == "Tx")
tx_stations
tx_stations <- isd_stations() %>% filter(state == "tx")
tx_stations
tx_stations <- isd_stations()# %>% filter(state == "tx")
count(tx_stations$state)
tx_stations$state
count(as.factor(tx_stations$state))
tx_stations$state[tx_stations$state != ""]
tx_stations <- isd_stations()# %>% filter(state == "TX")
tx_stations
tx_stations <- isd_stations() %>% filter(state == "TX")
tx_stations
require(rnoaa); require(magrittr); require(lubridate)
lubridate::as_date(tx_stations$begin)
lubridate::date(tx_stations$begin)
lubridate::date(tx_stations$begin[1])
lubridate::as_date(tx_stations$begin[1])
tx_stations$begin[1]
lubridate::ymd(tx_stations$begin[1])
read.table("~")
tx_stations <- isd_stations() %>%
filter(state == "TX") %>%
mutate(begin = ymd(begin)) %>%
mutate(end = ymd(end))
tx_stations$begin[1]
tx_stations
isd(tx_stations[1,1])
isd(tx_stations[1,1], tx_stations[1,2])
isd(tx_stations[1,1], tx_stations[1,2], 2012)
require(rnoaa); require(magrittr); require(lubridate)
my_token <- "TRUPCWweQbPjiXsfKCHqEokUUMZkitIs" # Token generated using my email (dwfletcher215@tamu.edu)
options(noaakey = my_token) # Sets token allowing interaction with API
current_date <- Sys.Date()
isd(tx_stations[1,1], tx_stations[1,2], 2012)
isd(tx_stations[1,1], tx_stations[1,2], 2016)
print(i)
for(i in seq_along(tx_stations)){
print(i)
}
for(i in row_number(tx_station)){
print(i)
}
for(i in row_number(tx_stations)){
print(i)
}
for(i in row.names(tx_stations)){
print(i)
}
for(i in 1:length(tx_stations)){
print(i)
}
for(i in 1:length(tx_stations)){
print(i)
}
tx_stations[1,1]
isd(tx_stations[1,1], tx_stations[1,2], 2016)
View(tx_stations)
source('~/6. GitHub/STAT-482-DASH/spatial dep.R', echo=TRUE)
library(igraph); library(spdep)
load("data.Rdata"); load("locs.Rdata")
rawData <- read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G <- graph.edgelist(as.matrix(rawData), directed=FALSE)
G <- simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid=V(G)$name %in% locs$Id2
countyGraph=induced.subgraph(G, V(G)[subFIPSid]);
graph0=permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat=as_adjacency_matrix(graph0)
# nb.mat = t(apply(nb.mat, 1, function(x){x/sum(x)}))
nb.w = mat2listw(nb.mat)
fit = lm(data$y~., data = data)
summary(fit)
plot(fit)
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
library(igraph); library(spdep)
load("data.Rdata"); load("locs.Rdata")
rawData <- read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G <- graph.edgelist(as.matrix(rawData), directed=FALSE)
G <- simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid=V(G)$name %in% locs$Id2
countyGraph=induced.subgraph(G, V(G)[subFIPSid]);
graph0=permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat=as_adjacency_matrix(graph0)
# nb.mat = t(apply(nb.mat, 1, function(x){x/sum(x)}))
nb.w = mat2listw(nb.mat)
fit = lm(data$y~., data = data)
summary(fit)
plot(fit)
spdep_test = lm.morantest(fit, nb.w, alternative="two.sided")
print(spdep_test)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
library(igraph); library(spdep)
load("data.Rdata"); load("locs.Rdata")
getwd()
setwd("C:/Users/dougl/OneDrive/Documents/6. Github")
wd()
setwd("C:/Users/dougl/OneDrive/Documents/6. Github/STAT-482-DASH")
library(igraph); library(spdep)
load("data.Rdata"); load("locs.Rdata")
rawData <- read.table("county_adjacency.munged.txt", colClasses=c("character", "character"))
G <- graph.edgelist(as.matrix(rawData), directed=FALSE)
G <- simplify(G, remove.loops=TRUE);V(G)$name=as.numeric(V(G)$name)
subFIPSid=V(G)$name %in% locs$Id2
countyGraph=induced.subgraph(G, V(G)[subFIPSid]);
graph0=permute(countyGraph, order(V(countyGraph)$name)); ### this is the dense graph to begin with.
nb.mat=as_adjacency_matrix(graph0)
# nb.mat = t(apply(nb.mat, 1, function(x){x/sum(x)}))
nb.w = mat2listw(nb.mat)
fit = lm(data$y~., data = data)
summary(fit)
plot(fit)
fit.lagrange = lm.LMtests(fit, nb.w, test=c("LMerr", "RLMerr", "LMlag", "RLMlag", "SARMA"))
print(fit.lagrange)
lm.morantest
help(lm.morantest)
par(mfrow = c(2,2))
print(fit.lagrange)
par(mfrow = c(2,2))
print(fit.lagrange)
par(mfrow = c(2,2))
print(fit.lagrange)
mat2listw
?mat2listw
par(mfrow = c(2,2))
plot(fit)
